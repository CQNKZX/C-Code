// if you only want code, this is it. I'm not sure which files should I discard, so I turn in a whole project and a single txt.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Lei_4882994_hw6
{
    class Program
    {
        static void Main(string[] args)
        {
            //K(strike price),S(current price),T(time to maturity), n(number of time steps)
            //r(risk-free rate),sigma(volatility),div(dividend rate),type(stand for euro or american option)
            double K, T, S, Sig, r, div, n, type;
            //directions of input
            Console.WriteLine("Please choose option style, 1 for european option, 2 for american option");
            type = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input strike price, by dollar");
            K = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input current underlying price, by dollar");
            S = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input time to maturity, by year");
            T = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input volatility, by decimal");
            Sig = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input risk free rate, by decimal");
            r = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input dividend rate, by decimal");
            div = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Please input number of time step in trinomial tree");
            n = Convert.ToDouble(Console.ReadLine());
            //create instance of option class to calculate option prices and greeks
            option myoption = new option();
            //create arraies to store result
            string[,] greekdisp = new string[2, 5] { { "call delta", "gamma", "vega", "call theta", "call rho" }, { "put delta", "gamma", "vega", "put theta", "put rho" } };
            double[] optionprices = new double[2];
            double[,] optiongreeks = new double[2,5];
            //logic control for option type
            if (type == 1)
            {
                //call euro style methods in option class
                optionprices = myoption.euopt(K, T, S, Sig, r, div, n);
                optiongreeks = myoption.eugreek(K, T, S, Sig, r, div, n);
            }
            else if (type == 2)
            {
                //call american style methods in option class
                optionprices = myoption.usopt(K, T, S, Sig, r, div, n);
                optiongreeks = myoption.usgreek(K, T, S, Sig, r, div, n);
            }
            else
            {
                Console.WriteLine("please run this program again");
            }
            //display results
            Console.WriteLine("call price = " + optionprices[0]);
            Console.WriteLine("put price = " + optionprices[1]);
            for (int ii = 0; ii <= 1; ii++)
            {
                for (int jj = 0; jj <= 4; jj++)
                {
                    Console.WriteLine(greekdisp[ii, jj] + " = " + optiongreeks[ii, jj]);
                }
            }
                Console.ReadLine();
        }

    }
    //create option class
    class option
    {
        int i, j; // define int for iteration
        double x, dx, t, v, pu, pm, pd, disc; //define parameters in trinomial tree
        //define method to calculate euro option prices
        public double[] euopt(double K, double T, double S, double Sig, double r, double div, double n)
        {
            
            t = T / n;//time increament
            v = r - div - 0.5 * Sig * Sig;
            disc = Math.Pow(Math.E,-r * t);//backward discount multiplier in each time step
            x=Sig * Math.Sqrt(3 * t);//underlying price increament in each time step
            dx = Math.Pow(Math.E, x);//for small x, x almost equals to e^x
            //jump probabilities, pu stands for jump up, pm stands for unchange, pd stands for jump down
            pu = ((Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2)) + v * t / x) / 2;
            pm = 1 - (Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2));
            pd = ((Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2)) - v * t / x) / 2;
            int size1 = Convert.ToInt16(n);//convert n to int for iteration and size of arraries
            //define arraries for calculates
            double[] assetprice = new double[2*size1+1];
            double[] callprice = new double[2 * size1 + 1];
            double[] putprice = new double[2 * size1 + 1];
            double[] optprice = new double[2];//final result
            //calculate final state of underlting price tree and option price tree
            for (i = 0; i <= 2*size1; i++)
            {
                assetprice[i] = S * Math.Pow(dx, n - i);
                callprice[i] = Math.Max(assetprice[i] - K, 0);
                putprice[i] = Math.Max(K - assetprice[i], 0);
            }
            //backward reduction
            for (i = size1; i >= 1; i--)
            {
                for (j = 0; j <= 2 * i - 2 ; j++)
                {
                    callprice[j] = disc * (pu * callprice[j] + pm * callprice[j + 1] + pd * callprice[j + 2]);
                    putprice[j] = disc * (pu * putprice[j] + pm * putprice[j + 1] + pd * putprice[j + 2]);
                }

            }
            //get call and put option prices
            optprice[0] = callprice[0];
            optprice[1] = putprice[0];
            return optprice;
        }
        //define method to calculate euro option prices
        public double[] usopt(double K, double T, double S, double Sig, double r, double div, double n)
        {

            t = T / n;
            v = r - div - 0.5 * Sig * Sig;
            disc = Math.Pow(Math.E, -r * t);
            x = Sig * Math.Sqrt(3 * t);
            dx = Math.Pow(Math.E, x);
            pu = ((Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2)) + v * t / x) / 2;
            pm = 1 - (Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2));
            pd = ((Sig * Sig * t + v * v * t * t) / (Math.Pow(x, 2)) - v * t / x) / 2;
            int size = Convert.ToInt16(n);
            double[,] callprice = new double[2 * size + 2, size + 1];
            double[,] putprice = new double[2 * size + 2, size + 1];
            double[] usopt = new double[2];
            double temp1, temp2;
            //get entire trees
            for (i = 0; i <= size; i++)
            {
                for (j = 0; j <= 2 * i; j++)
                {
                    callprice[j , i] = S * Math.Pow(dx, i - j);
                    putprice[j, i] = S * Math.Pow(dx, i - j);
                }
            }
            //get final state of option price trees
            for (i = 0; i <= 2 * size + 1; i++)
            {
                temp1 = callprice[i, size] - K;
                callprice[i, size] = Math.Max(temp1, 0);
                temp2 = K - putprice[i, size];
                putprice[i, size] = Math.Max(temp2, 0);
            }
            //backward reduction
            for (i = size - 1;i >= 0;  i--)
            {
                for (j = 0; j <= 2 * i; j++)
                {
                    temp1 = disc * (pu * callprice[j, i + 1] + pm * callprice[j + 1, i + 1] + pd * callprice[j + 2, i + 1]);
                    callprice[j, i] = Math.Max(temp1, (callprice[j, i] - K));
                    temp2 = disc * (pu * putprice[j, i + 1] + pm * putprice[j + 1, i + 1] + pd * putprice[j + 2, i + 1]);
                    putprice[j, i] = Math.Max(temp2, (K - putprice[j, i]));
                }
            }
            //get call and put option prices
            usopt[0] = callprice[0,0];
            usopt[1] = putprice[0,0];
            return usopt;
        }
        //define method to calculate euro option greeks, just by definition of derivative
        public double[,] eugreek(double K, double T, double S, double Sig, double r, double div, double n)
        {
            double[] temp1, temp2, temp3 = new double[2];
            double cdlt, pdlt, gamma, vega, cth, pth, crho, prho;
            double t1 = T / n;
            double x1 = Sig * Math.Sqrt(3 * t1);
            double dx1 = Math.Pow(Math.E, x1);//underlying price inreament multiplier
            temp1 = euopt(K, T, S * dx1, Sig, r, div, n);
            temp2 = euopt(K, T, S, Sig, r, div, n);
            temp3 = euopt(K, T, S / dx1, Sig, r, div, n);
            cdlt = (temp1[0] - temp3[0]) / (S * dx1 - S / dx1);
            pdlt = (temp1[1] - temp3[1]) / ((S * dx1 - S / dx1));
            gamma = ((temp1[0] - temp2[0]) / ((S * dx1 - S)) - (temp2[0] - temp3[0]) / ((S - S / dx1))) / ((S * dx1 - S / dx1) / 2);
            vega = (euopt(K, T, S, Sig + 0.000001, r, div, n)[0] - euopt(K, T, S, Sig - 0.000001, r, div, n)[0]) / (2 * 0.000001);
            temp1 = euopt(K, T + 0.000001, S, Sig, r, div, n);
            temp3 = euopt(K, T - 0.000001, S, Sig, r, div, n);
            cth = -(temp1[0] - temp3[0]) / (2 * 0.000001);
            pth = -(temp1[1] - temp3[1]) / (2 * 0.000001);
            temp1 = euopt(K, T, S, Sig, r + 0.000001, div, n);
            temp3 = euopt(K, T, S, Sig, r - 0.000001, div, n);
            crho = (temp1[0] - temp3[0]) / (2 * 0.000001);
            prho = (temp1[1] - temp3[1]) / (2 * 0.000001);
            //get result
            double[,] eugreek = new double[2 , 5]{{cdlt, gamma, vega, cth, crho},{pdlt, gamma, vega, pth, prho}};
            return eugreek;
        }
        //define method to calculate american option greeks, just by definition of derivative
        public double[,] usgreek(double K, double T, double S, double Sig, double r, double div, double n)
        {
            double[] temp1, temp2, temp3 = new double[2];
            double cdlt, pdlt, gamma, vega, cth, pth, crho, prho;
            double t1 = T / n;
            double x1 = Sig * Math.Sqrt(3 * t1);
            double dx1 = Math.Pow(Math.E, x1);
            temp1 = usopt(K, T, S * dx1, Sig, r, div, n);
            temp2 = usopt(K, T, S, Sig, r, div, n);
            temp3 = usopt(K, T, S / dx1, Sig, r, div, n);
            cdlt = (temp1[0] - temp3[0]) / (S * dx1 - S / dx1);
            pdlt = (temp1[1] - temp3[1]) / ((S * dx1 - S / dx1));
            gamma = ((temp1[0] - temp2[0]) / ((S * dx1 - S)) - (temp2[0] - temp3[0]) / ((S - S / dx1))) / ((S * dx1 - S / dx1) / 2);
            vega = (usopt(K, T, S, Sig + 0.000001, r, div, n)[0] - usopt(K, T, S, Sig - 0.000001, r, div, n)[0]) / (2 * 0.000001);
            temp1 = usopt(K, T + 0.000001, S, Sig, r, div, n);
            temp3 = usopt(K, T - 0.000001, S, Sig, r, div, n);
            cth = -(temp1[0] - temp3[0]) / (2 * 0.000001);
            pth = -(temp1[1] - temp3[1]) / (2 * 0.000001);
            temp1 = usopt(K, T, S, Sig, r + 0.000001, div, n);
            temp3 = usopt(K, T, S, Sig, r - 0.000001, div, n);
            crho = (temp1[0] - temp3[0]) / (2 * 0.000001);
            prho = (temp1[1] - temp3[1]) / (2 * 0.000001);
            //get result
            double[,] usgreek = new double[2, 5] { { cdlt, gamma, vega, cth, crho }, { pdlt, gamma, vega, pth, prho } };
            return usgreek;
        }
    }
}
